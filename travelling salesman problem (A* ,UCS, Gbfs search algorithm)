"""Problem Statement :
A courier company in Chandigarh needs to deliver parcels from a central warehouse to multiple customers.
City modeled as a weighted graph:
Nodes → warehouse, customer houses, landmarks
Edges → roads with travel time/cost
Courier AI must plan:
     Single-destination delivery:
     Use A* search from warehouse → one customer
     Heuristic h(n): straight-line distance to destination
     Multi-destination delivery:
     Use TSP to compute optimal route visiting all customers once and returning to warehouse.
concept used : 
Heuristic Search (A*)
Travelling Salesman Problem (TSP)
Graph Representation (nodes, edges, weights)
Algorithm Comparison (Greedy vs UCS vs A*)"""

import heapq
import itertools

graph = {
    'Warehouse': {'A': 2, 'B': 5},
    'A': {'Warehouse': 2, 'B': 2, 'C': 4},
    'B': {'Warehouse': 5, 'A': 2, 'C': 1, 'D': 6},
    'C': {'A': 4, 'B': 1, 'D': 3},
    'D': {'B': 6, 'C': 3}
}

# distance heuristic to destination D
heuristic = {
    'Warehouse': 7,
    'A': 6,
    'B': 2,
    'C': 1,
    'D': 0
}

def a_star(start, goal, graph, heuristic):
    open_list = []
    heapq.heappush(open_list, (heuristic[start], 0, start, [start]))  # (f, g, node, path)
    expanded_nodes = []

    while open_list:
        f, g, node, path = heapq.heappop(open_list)
        expanded_nodes.append(node)

        if node == goal:
            return path, g, expanded_nodes

        for neighbor, cost in graph[node].items():
            if neighbor not in path:
                g_new = g + cost
                f_new = g_new + heuristic[neighbor]
                heapq.heappush(open_list, (f_new, g_new, neighbor, path + [neighbor]))
    return None, float('inf'), expanded_nodes

def ucs(start, goal, graph):
    open_list = []
    heapq.heappush(open_list, (0, start, [start]))
    expanded_nodes = []

    while open_list:
        cost, node, path = heapq.heappop(open_list)
        expanded_nodes.append(node)
        if node == goal:
            return path, cost, expanded_nodes
        for neighbor, c in graph[node].items():
            if neighbor not in path:
                heapq.heappush(open_list, (cost + c, neighbor, path + [neighbor]))
    return None, float('inf'), expanded_nodes

def gbfs(start, goal, graph, heuristic):
    open_list = []
    heapq.heappush(open_list, (heuristic[start], start, [start]))
    expanded_nodes = []

    while open_list:
        h, node, path = heapq.heappop(open_list)
        expanded_nodes.append(node)
        if node == goal:
            # Calculate actual path cost
            total_cost = sum(graph[path[i]][path[i+1]] for i in range(len(path)-1))
            return path, total_cost, expanded_nodes
        for neighbor in graph[node]:
            if neighbor not in path:
                heapq.heappush(open_list, (heuristic[neighbor], neighbor, path + [neighbor]))
    return None, float('inf'), expanded_nodes

def complete_graph(graph):
    # Create a fully connected graph with shortest path cost between nodes
    nodes = list(graph.keys())
    complete = {node: {} for node in nodes}
    
    # Use Dijkstra to find shortest paths between all pairs
    for src in nodes:
        # Initialize distances
        dist = {n: float('inf') for n in nodes}
        dist[src] = 0
        visited = set()
        heap = [(0, src)]
        while heap:
            d, u = heapq.heappop(heap)
            if u in visited:
                continue
            visited.add(u)
            for v, cost in graph[u].items():
                if dist[v] > d + cost:
                    dist[v] = d + cost
                    heapq.heappush(heap, (dist[v], v))
        # Fill complete graph distances
        for v in nodes:
            if v != src:
                complete[src][v] = dist[v]
    return complete

def tsp(graph, start):
    # Make graph fully connected using shortest paths
    full_graph = complete_graph(graph)
    nodes = list(full_graph.keys())
    nodes.remove(start)
    min_cost = float('inf')
    best_path = []

    for perm in itertools.permutations(nodes):
        cost = 0
        path = [start] + list(perm) + [start]
        for i in range(len(path)-1):
            cost += full_graph[path[i]][path[i+1]]
        if cost < min_cost:
            min_cost = cost
            best_path = path
    return best_path, min_cost

start = 'Warehouse'
goal = 'D'

print("A* Search:")
path, cost, expanded = a_star(start, goal, graph, heuristic)
print("Expanded nodes:", expanded)
print("Path:", path)
print("Cost:", cost)

print("\nUCS:")
path_ucs, cost_ucs, expanded_ucs = ucs(start, goal, graph)
print("Expanded nodes:", expanded_ucs)
print("Path:", path_ucs)
print("Cost:", cost_ucs)

print("\nGreedy bfs:")
path_gbfs, cost_gbfs, expanded_gbfs = gbfs(start, goal, graph, heuristic)
print("Expanded nodes:", expanded_gbfs)
print("Path:", path_gbfs)
print("Cost:", cost_gbfs)

print("\nTSP Travelling Salesman Problem:")
tour, min_cost = tsp_bruteforce(graph, start)
print("Tour path:", tour)
print("Minimum cost:", min_cost)

